/**
 * FreeChat OpenAPI Definition
 * https://github.com/freechat-fun/freechat
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import FlowCreateDTO from '../model/FlowCreateDTO';
import FlowDetailsDTO from '../model/FlowDetailsDTO';
import FlowItemForNameDTO from '../model/FlowItemForNameDTO';
import FlowQueryDTO from '../model/FlowQueryDTO';
import FlowSummaryDTO from '../model/FlowSummaryDTO';
import FlowUpdateDTO from '../model/FlowUpdateDTO';

/**
* Flow service.
* @module api/FlowApi
* @version 0.1.0
*/
export default class FlowApi {

    /**
    * Constructs a new FlowApi. 
    * @alias module:api/FlowApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Batch Search Flow Details
     * Batch call shortcut for /api/v1/flow/details/search.
     * @param {Array.<module:model/FlowQueryDTO>} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<[FlowDetailsDTO]>} and HTTP response
     */
    batchSearchFlowDetailsWithHttpInfo(flowQueryDTO) {
      let postBody = flowQueryDTO;
      // verify the required parameter 'flowQueryDTO' is set
      if (flowQueryDTO === undefined || flowQueryDTO === null) {
        throw new Error("Missing the required parameter 'flowQueryDTO' when calling batchSearchFlowDetails");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [[FlowDetailsDTO]];
      return this.apiClient.callApi(
        '/api/v1/flow/batch/details/search', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Batch Search Flow Details
     * Batch call shortcut for /api/v1/flow/details/search.
     * @param {Array.<module:model/FlowQueryDTO>} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<[FlowDetailsDTO]>}
     */
    batchSearchFlowDetails(flowQueryDTO) {
      return this.batchSearchFlowDetailsWithHttpInfo(flowQueryDTO)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Batch Search Flow Summaries
     * Batch call shortcut for /api/v1/flow/search.
     * @param {Array.<module:model/FlowQueryDTO>} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<[FlowSummaryDTO]>} and HTTP response
     */
    batchSearchFlowSummaryWithHttpInfo(flowQueryDTO) {
      let postBody = flowQueryDTO;
      // verify the required parameter 'flowQueryDTO' is set
      if (flowQueryDTO === undefined || flowQueryDTO === null) {
        throw new Error("Missing the required parameter 'flowQueryDTO' when calling batchSearchFlowSummary");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [[FlowSummaryDTO]];
      return this.apiClient.callApi(
        '/api/v1/flow/batch/search', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Batch Search Flow Summaries
     * Batch call shortcut for /api/v1/flow/search.
     * @param {Array.<module:model/FlowQueryDTO>} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<[FlowSummaryDTO]>}
     */
    batchSearchFlowSummary(flowQueryDTO) {
      return this.batchSearchFlowSummaryWithHttpInfo(flowQueryDTO)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Clone Flow
     * Enter the flowId, generate a new record, the content is basically the same as the original flow, but the following fields are different: - Version number is 1 - Visibility is private - The parent flow is the source flowId - The creation time is the current moment.  - All statistical indicators are zeroed.  Return the new flowId. 
     * @param {String} flowId The referenced flowId
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link String} and HTTP response
     */
    cloneFlowWithHttpInfo(flowId) {
      let postBody = null;
      // verify the required parameter 'flowId' is set
      if (flowId === undefined || flowId === null) {
        throw new Error("Missing the required parameter 'flowId' when calling cloneFlow");
      }

      let pathParams = {
        'flowId': flowId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['text/plain'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/flow/clone/{flowId}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Clone Flow
     * Enter the flowId, generate a new record, the content is basically the same as the original flow, but the following fields are different: - Version number is 1 - Visibility is private - The parent flow is the source flowId - The creation time is the current moment.  - All statistical indicators are zeroed.  Return the new flowId. 
     * @param {String} flowId The referenced flowId
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link String}
     */
    cloneFlow(flowId) {
      return this.cloneFlowWithHttpInfo(flowId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Batch Clone Flows
     * Batch clone multiple flows. Ensure transactionality, return the flowId list after success.
     * @param {Array.<String>} requestBody List of flow information to be created
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<String>} and HTTP response
     */
    cloneFlowsWithHttpInfo(requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling cloneFlows");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/api/v1/flow/batch/clone', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Batch Clone Flows
     * Batch clone multiple flows. Ensure transactionality, return the flowId list after success.
     * @param {Array.<String>} requestBody List of flow information to be created
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<String>}
     */
    cloneFlows(requestBody) {
      return this.cloneFlowsWithHttpInfo(requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Calculate Number of Flows
     * Calculate the number of flows according to the specified query conditions.
     * @param {module:model/FlowQueryDTO} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Number} and HTTP response
     */
    countFlowsWithHttpInfo(flowQueryDTO) {
      let postBody = flowQueryDTO;
      // verify the required parameter 'flowQueryDTO' is set
      if (flowQueryDTO === undefined || flowQueryDTO === null) {
        throw new Error("Missing the required parameter 'flowQueryDTO' when calling countFlows");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = 'Number';
      return this.apiClient.callApi(
        '/api/v1/flow/count', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Calculate Number of Flows
     * Calculate the number of flows according to the specified query conditions.
     * @param {module:model/FlowQueryDTO} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Number}
     */
    countFlows(flowQueryDTO) {
      return this.countFlowsWithHttpInfo(flowQueryDTO)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create Flow
     * Create a flow, ignore required fields: - Flow name - Flow configuration  Limitations: - Description: 300 characters - Configuration: 2000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
     * @param {module:model/FlowCreateDTO} flowCreateDTO Information of the flow to be created
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link String} and HTTP response
     */
    createFlowWithHttpInfo(flowCreateDTO) {
      let postBody = flowCreateDTO;
      // verify the required parameter 'flowCreateDTO' is set
      if (flowCreateDTO === undefined || flowCreateDTO === null) {
        throw new Error("Missing the required parameter 'flowCreateDTO' when calling createFlow");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['text/plain'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/flow', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create Flow
     * Create a flow, ignore required fields: - Flow name - Flow configuration  Limitations: - Description: 300 characters - Configuration: 2000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
     * @param {module:model/FlowCreateDTO} flowCreateDTO Information of the flow to be created
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link String}
     */
    createFlow(flowCreateDTO) {
      return this.createFlowWithHttpInfo(flowCreateDTO)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Batch Create Flows
     * Batch create multiple flows. Ensure transactionality, return the flowId list after success.
     * @param {Array.<module:model/FlowCreateDTO>} flowCreateDTO List of flow information to be created
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<String>} and HTTP response
     */
    createFlowsWithHttpInfo(flowCreateDTO) {
      let postBody = flowCreateDTO;
      // verify the required parameter 'flowCreateDTO' is set
      if (flowCreateDTO === undefined || flowCreateDTO === null) {
        throw new Error("Missing the required parameter 'flowCreateDTO' when calling createFlows");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/api/v1/flow/batch', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Batch Create Flows
     * Batch create multiple flows. Ensure transactionality, return the flowId list after success.
     * @param {Array.<module:model/FlowCreateDTO>} flowCreateDTO List of flow information to be created
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<String>}
     */
    createFlows(flowCreateDTO) {
      return this.createFlowsWithHttpInfo(flowCreateDTO)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete Flow
     * Delete flow. Return success or failure.
     * @param {String} flowId FlowId to be deleted
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Boolean} and HTTP response
     */
    deleteFlowWithHttpInfo(flowId) {
      let postBody = null;
      // verify the required parameter 'flowId' is set
      if (flowId === undefined || flowId === null) {
        throw new Error("Missing the required parameter 'flowId' when calling deleteFlow");
      }

      let pathParams = {
        'flowId': flowId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = 'Boolean';
      return this.apiClient.callApi(
        '/api/v1/flow/{flowId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete Flow
     * Delete flow. Return success or failure.
     * @param {String} flowId FlowId to be deleted
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Boolean}
     */
    deleteFlow(flowId) {
      return this.deleteFlowWithHttpInfo(flowId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Batch Delete Flows
     * Delete multiple flows. Ensure transactionality, return the list of successfully deleted flowId.
     * @param {Array.<String>} requestBody List of flowId to be deleted
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<String>} and HTTP response
     */
    deleteFlowsWithHttpInfo(requestBody) {
      let postBody = requestBody;
      // verify the required parameter 'requestBody' is set
      if (requestBody === undefined || requestBody === null) {
        throw new Error("Missing the required parameter 'requestBody' when calling deleteFlows");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/api/v1/flow/batch/delete', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Batch Delete Flows
     * Delete multiple flows. Ensure transactionality, return the list of successfully deleted flowId.
     * @param {Array.<String>} requestBody List of flowId to be deleted
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<String>}
     */
    deleteFlows(requestBody) {
      return this.deleteFlowsWithHttpInfo(requestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Flow Details
     * Get flow detailed information.
     * @param {String} flowId FlowId to be obtained
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowDetailsDTO} and HTTP response
     */
    getFlowDetailsWithHttpInfo(flowId) {
      let postBody = null;
      // verify the required parameter 'flowId' is set
      if (flowId === undefined || flowId === null) {
        throw new Error("Missing the required parameter 'flowId' when calling getFlowDetails");
      }

      let pathParams = {
        'flowId': flowId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowDetailsDTO;
      return this.apiClient.callApi(
        '/api/v1/flow/details/{flowId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Flow Details
     * Get flow detailed information.
     * @param {String} flowId FlowId to be obtained
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowDetailsDTO}
     */
    getFlowDetails(flowId) {
      return this.getFlowDetailsWithHttpInfo(flowId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get Flow Summary
     * Get flow summary information.
     * @param {String} flowId flowId to be obtained
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlowSummaryDTO} and HTTP response
     */
    getFlowSummaryWithHttpInfo(flowId) {
      let postBody = null;
      // verify the required parameter 'flowId' is set
      if (flowId === undefined || flowId === null) {
        throw new Error("Missing the required parameter 'flowId' when calling getFlowSummary");
      }

      let pathParams = {
        'flowId': flowId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowSummaryDTO;
      return this.apiClient.callApi(
        '/api/v1/flow/summary/{flowId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get Flow Summary
     * Get flow summary information.
     * @param {String} flowId flowId to be obtained
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlowSummaryDTO}
     */
    getFlowSummary(flowId) {
      return this.getFlowSummaryWithHttpInfo(flowId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Versions by Flow Name
     * List the versions and corresponding flowIds by flow name.
     * @param {String} name Flow name
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FlowItemForNameDTO>} and HTTP response
     */
    listFlowVersionsByNameWithHttpInfo(name) {
      let postBody = null;
      // verify the required parameter 'name' is set
      if (name === undefined || name === null) {
        throw new Error("Missing the required parameter 'name' when calling listFlowVersionsByName");
      }

      let pathParams = {
        'name': name
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [FlowItemForNameDTO];
      return this.apiClient.callApi(
        '/api/v1/flow/versions/{name}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Versions by Flow Name
     * List the versions and corresponding flowIds by flow name.
     * @param {String} name Flow name
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FlowItemForNameDTO>}
     */
    listFlowVersionsByName(name) {
      return this.listFlowVersionsByNameWithHttpInfo(name)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Publish Flow
     * Publish flow, draft content becomes formal content, version number increases by 1. After successful publication, a new flowId will be generated and returned. You need to specify the visibility for publication.
     * @param {String} flowId The flowId to be published
     * @param {String} visibility Visibility: public | private | ...
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link String} and HTTP response
     */
    publishFlowWithHttpInfo(flowId, visibility) {
      let postBody = null;
      // verify the required parameter 'flowId' is set
      if (flowId === undefined || flowId === null) {
        throw new Error("Missing the required parameter 'flowId' when calling publishFlow");
      }
      // verify the required parameter 'visibility' is set
      if (visibility === undefined || visibility === null) {
        throw new Error("Missing the required parameter 'visibility' when calling publishFlow");
      }

      let pathParams = {
        'flowId': flowId,
        'visibility': visibility
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['text/plain'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/api/v1/flow/publish/{flowId}/{visibility}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Publish Flow
     * Publish flow, draft content becomes formal content, version number increases by 1. After successful publication, a new flowId will be generated and returned. You need to specify the visibility for publication.
     * @param {String} flowId The flowId to be published
     * @param {String} visibility Visibility: public | private | ...
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link String}
     */
    publishFlow(flowId, visibility) {
      return this.publishFlowWithHttpInfo(flowId, visibility)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Search Flow Details
     * Same as /api/v1/flow/search, but returns detailed information of the flow.
     * @param {module:model/FlowQueryDTO} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FlowDetailsDTO>} and HTTP response
     */
    searchFlowDetailsWithHttpInfo(flowQueryDTO) {
      let postBody = flowQueryDTO;
      // verify the required parameter 'flowQueryDTO' is set
      if (flowQueryDTO === undefined || flowQueryDTO === null) {
        throw new Error("Missing the required parameter 'flowQueryDTO' when calling searchFlowDetails");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [FlowDetailsDTO];
      return this.apiClient.callApi(
        '/api/v1/flow/details/search', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Search Flow Details
     * Same as /api/v1/flow/search, but returns detailed information of the flow.
     * @param {module:model/FlowQueryDTO} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FlowDetailsDTO>}
     */
    searchFlowDetails(flowQueryDTO) {
      return this.searchFlowDetailsWithHttpInfo(flowQueryDTO)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Search Flow Summary
     * Search flows: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Format: exact match, currently supported: langflow   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - General: name, description, example, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the flow summary content. - Support pagination. 
     * @param {module:model/FlowQueryDTO} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FlowSummaryDTO>} and HTTP response
     */
    searchFlowSummaryWithHttpInfo(flowQueryDTO) {
      let postBody = flowQueryDTO;
      // verify the required parameter 'flowQueryDTO' is set
      if (flowQueryDTO === undefined || flowQueryDTO === null) {
        throw new Error("Missing the required parameter 'flowQueryDTO' when calling searchFlowSummary");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [FlowSummaryDTO];
      return this.apiClient.callApi(
        '/api/v1/flow/search', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Search Flow Summary
     * Search flows: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Format: exact match, currently supported: langflow   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - General: name, description, example, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the flow summary content. - Support pagination. 
     * @param {module:model/FlowQueryDTO} flowQueryDTO Query conditions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FlowSummaryDTO>}
     */
    searchFlowSummary(flowQueryDTO) {
      return this.searchFlowSummaryWithHttpInfo(flowQueryDTO)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update Flow
     * Update flow, refer to /api/v1/flow/create, required field: flowId. Return success or failure.
     * @param {String} flowId FlowId to be updated
     * @param {module:model/FlowUpdateDTO} flowUpdateDTO Flow information to be updated
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Boolean} and HTTP response
     */
    updateFlowWithHttpInfo(flowId, flowUpdateDTO) {
      let postBody = flowUpdateDTO;
      // verify the required parameter 'flowId' is set
      if (flowId === undefined || flowId === null) {
        throw new Error("Missing the required parameter 'flowId' when calling updateFlow");
      }
      // verify the required parameter 'flowUpdateDTO' is set
      if (flowUpdateDTO === undefined || flowUpdateDTO === null) {
        throw new Error("Missing the required parameter 'flowUpdateDTO' when calling updateFlow");
      }

      let pathParams = {
        'flowId': flowId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = 'Boolean';
      return this.apiClient.callApi(
        '/api/v1/flow/{flowId}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update Flow
     * Update flow, refer to /api/v1/flow/create, required field: flowId. Return success or failure.
     * @param {String} flowId FlowId to be updated
     * @param {module:model/FlowUpdateDTO} flowUpdateDTO Flow information to be updated
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Boolean}
     */
    updateFlow(flowId, flowUpdateDTO) {
      return this.updateFlowWithHttpInfo(flowId, flowUpdateDTO)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
